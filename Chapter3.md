# Pointer 
## 목차
1. [포인터와 배열](#포인터와-배열)<br>
1. [배열을 매개변수로 갖는 함수](#배열을-매개변수로-갖는-함수)<br>
1. [문자열 포인터와 문자 배열의 차이점](#문자열-포인터와-문자-배열의-차이점)<br>
1. [동적 메모리 할당](#동적-메모리-할당)<br>
***
## 포인터와 배열
- 배열 이름은 포인터이고, 그 값은 배열 첫 원소의 주소 값<br>
- 포인터에 배열의 원소를 지정하는 첨자 사용가능<br>
- 배열 이름은 고정된 주소를 갖는 상수 포인터
***
- ex1)
```C
int array[3] = {1, 2, 3};
array = array + 1;  // 오류(상수)
array++;            // 오류(상수)
```

- ex2)
```C
int arr[100], i, *p;    // a[0]의 주소를 갖는 int형 포인터
i = 5;
p = arr;                // p = &arr[0];
p = a + i;              // a[0]에서 i번째 떨어진 원소 위치(주소)
p[i] = 10;              // p[i] == *(p + i);
```
- ex3)
```C
int a[N], i, *p;    // &a[0]가 300번지 라고 가정,
p = a + 1;          // p = &a[1];
```
<br>
ex3)의 예시<br>

|주소 | 메모리 ||
|---|:---:|---|
|300|a[0]|
|304|a[1]/p[0]| p = a + 1 |
|308|a[2]/p[1]|
|...|...|
|696|a[99]/p[98]|

- ex4) 
```C
int arr[3] = {1, 2, 3};
int *p = arr;

/*
위와 같다면, 아래는 4가지는 모두 동일한 수식임.
arr[0], *(arr + 0), p[0], *(p + 0)
*/
```
- 2차원 배열도 인덱스를 하나 제거하면 포인터가 됨

int b[3][5];<br>
-> b[i]         // int형 포인터, &b[i][0]<br>
-> b[i] + j     // &b[i][j]<br>

|||||||
|---|---|---|---|---|---|
|b[0][0]|b[0][1]|||| <- b
|b[1][0]|||b[1][3]|| <- b + 1
|b[2][0]||||b[2][4]| <- b + 2

b[0] = b[0][0]<br>
b[1] = b[1][0]<br>
b[2] = b[2][0]<br>

b[0][1] = b[0] + 1<br>
b[1][3] = b[1] + 3<br>

b = 1행 전체<br>
b + 1 = 2행 전체<br>
b + 2 = 3행 전체

- cf) 배열의 다양한 표현<br>
b[i][j] <br>= *(b[i] + j) <br>= *(*b+i)+j)<br> = (*(b+i))[j]
***
## 배열을 매개변수로 갖는 함수
- 배열 매개변수는 포인터임
***
- ex )
```C
int grade_sum2(int gr[], int size){
    ...함수 내용...
}
```
int gr[] == int *gr
* 자세한 사용 방법은 [동적 메모리 할당](#동적-메모리-할당) 페이지 ex)에서 알아봄
***
## 문자열 포인터와 문자 배열의 차이점
- 문자열 포인터는 포인터가 문자열 배열을 가르키고 있다고 보면 됨
***
- ex1)
```C
char *p = "abcde";  // 문자열 포인터
char s[] = "abcde"; // 문자 배열

printf("%c %c %c %c", p[0], *p, s[0], *s);
// a a a a

printf("%s %s", p, s);
// abcde abcde

printf("%s %s", p+1, s+1);
// bcde bcde
```
- ex2)
```C
#define N 20

char name[N] = ""       // NULL로 초기화
char *name_p;
scanf("%s", name);
scanf("%s", name_p);    // 오류
```
name_p는 포인터 변수를 할당하지 않았기 때문에 쓰레기 값이 들어있다. 따라서 포인터가 제대로 된 길을 찾지 못해서 오류가 발생한다.

`name_p = name;` 처럼 포인터 변수를 할당하여 해결한다.
***
## 동적 메모리 할당
- <stdlib.h> 헤더를 포함하여 사용한다.

- Calloc
    - 함수 원형 : `void* calloc (size_t N, el_size);`
    <br>
    <u>**0으로 초기화**</u>

- Malloc
    - 함수 원형 : `void* malloc(size_t N_bytes);`<br>
    <u>**초기화 안함**</u>

- 사용 후 free()로 메모리 해제
***
- ex)
```C
#include <stdlib.h>

int main(){
    int *grade, N;

    scanf("%d", &N);    // 10입력, N == 10

    grade = (int*)calloc(N, sizeof(int));   // 또는 (int*)malloc(sizeof(int)*N);

    for(int i = 0; i < N; i++)
        scanf("%d", &grade[i]);

    free(grade);
    grade = NULL;
}
```
