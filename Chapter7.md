# 비트 수준 접근
## 목차

  - [비트 수준 접근이란?](#비트-수준-접근이란?)
  - [비트 단위 연산자](#비트-단위-연산자)
    - [논리 연산자](#논리-연산자)
      - [~ 연산자](#-연산자)
      - [&, ^, | 연산자](#---연산자)
    - [이동 연산자](#이동-연산자)
      - [왼쪽 이동 연산자 <<](#왼쪽-이동-연산자-)
      - [오른쪽 이동 연산자 >>](#오른쪽-이동-연산자-)
  - [마스킹 연산](#마스킹-연산)
  - [패킹과 언패킹](#패킹과-언패킹)
    - [패킹](#패킹)
    - [언패킹](#언패킹)

***
## 비트 수준 접근이란?
- 모든 내용은 메모리에 이진값으로 저장
- 참고)
  - 비트(bit) : 이진 값의 각 자리
  - 바이트(bytes) : 8bit  // 1 byte = 8 bit
  - 워드(word) : 메모리에서 읽혀지는 단위

- ex)
```c
0101 1101

= 93(10진수) (= 2^6 + 2^4 + 2^3 + 2^2 + 2^0)
= 5D(16진수) (= 0101 = 5, 1101 = D)
+) 비트열을 다룰 때는 16진수를 많이 사용
```

***
## 비트 단위 연산자
- 논리 연산자
  - 비트 단위 보수 ~
  - 비트 단위 논리곱 &
  - 비트 단위 배타적 논리합 ^
  - 비트 단위 논리합 |
- 이동 연산자
  - 왼쪽 이동 <<
  - 오른쪽 이동 >>
***
### 논리 연산자

***
#### ~ 연산자
- 1의 보수 연산자, 비트 단위 보수 연산자
- 1은 0으로, 0은 1로 변환함<br>
<br>
___
- ex) 

```c
a가 6일 때,
- a의 이진수 표현
0000 0110

- ~a의 이진수 표현
1111 1001
```

***
#### &, ^, | 연산자
- &(논리곱), |(논리합), ^(배타적 논리합)
- 두 피연산자는 대응되는 비트끼리 연산됨.

a|b|a&b|a^b|a\|b
:---:|:---:|:---:|:---:|:---:
0|0|0|0|0
1|0|0|1|1
0|1|0|1|1
1|1|1|0|1

- & : 모두 참 일 때만, 참(true)
- ^ : 두 비트가 서로 다를 때, 참
- | : 하나라도 참이면, 참
<br>
<br>
---
- ex2)

```c
a = 33333, b = -77777, c = 0, d = 0, e = 0 

c = a&b
d = a|b
e = a^b 일 때, 

1. c) 하위 7비트

a 0110101
&
b 0101111
---------
c 0100101

2. d) 하위 7비트

a 0110101
|
b 0101111
---------
d 0111111

3. e) 하위 7비트

a 0110101
^
b 0101111
---------
e 0011010

```

***
### 이동 연산자
- 지정된 값의 비트열을 이동시키는 연산자
- 두 피연산자는 정수 수식이어야 함.
***
#### 왼쪽 이동 연산자 <<
## 수식1 << 수식2
  - 수식1의 비트 표현을 수기2가 지정하는 수 만큼 왼쪽으로 이동
  - 왼쪽 이동으로 발생하는 빈 공간은 0으로 채워짐
  <br>-> 2의 거듭제곱 효과
***
- ex)
```c
c = 7   // 0000 0111

c << 1    // 0000 1110 (= 14 (= 7 * 2^1))

c << 8    // 111 0000 0000 (= 1792 (= 7 * 2^8))
```
#### 오른쪽 이동 연산자 >>
## 수식1 >> 수식2
  - 수식1의 비트 표현을 수식2가 지정하는 수 만큼 오른쪽으로 이동
  - 수식1이 unsigned 형이면, 상위 비트로 0이 들어옴<br>
  -> 2의 거듭제곱으로 나누기 연산 효과
  - 수식 1이 signed 형이면 시스템 종속적
  ____
- ex)
```c
c = 4026531840   // 1111 0000 0000... 0000

c >> 1    // 0111 1000 0000... 0000 (= 2013265920 (= c / 2^1))

c >> 8    // 0000 0000 1111 0000... 0000 (= 15728640 (= c / 2^8))
```
***
## 마스킹 연산
- & 연산자를 사용하여 주어진 비트열의 특정 비트를 0으로 만드는 것
- 마스크 : 마스킹 연산을 위해 사용되는 상수나 변수

- ex)
```c
int i, mask = 1;
// mask : 00000001

for(i = 0; i < 10; i++){
  printf("%d ", i&mask);
} // i가 홀수면 1, 짝수면 0 출력
```
***
## 패킹과 언패킹
- 패킹 : 여러 정보를 비트 단위 연산자를 사용하여 적은 바이트로 압축하는 것<br>
-> 메모리 절약, 전송 시간 줄임
-  언패킹 : 패킹된 정보를 사용하기 전에 정보를 추출하는 것

***
### 패킹
- 직원 관리 프로그램에서 다음과 같은 정보를 다루어야 한다고 가정.
  - 직원 ID : 6자리 (10진수)
  - 작업 형태 : 200자리
  - 성별

- 이 3가지 정보는 unsigned int에 패킹 가능
 - 직원 ID : 20비트 (2^6 = 32)
 - 작업 형태 : 8비트 (2^8 = 256)
 - 성별 : 1비트
<br>-> 총 : 29비트
---
- ex)
```c
xxxb     bbbb bbbb       bbbb bbbb bbbb bbbb bbbb
  성별      작업 형태               직원 ID
```

- ex2)
```c
unsigned pack_data(unsigned in_no, unsigned job_type, char gender){
  unsigned employee = 0;
  employee |= id_no;
  employee |= job_type << 20;
  employee |= ((gender == 'm' || gender == 'M') ? 0: 1) << 28;

  return employee;
}
```
***
### 언패킹
- 적절한 마스크 필요
- 직원 관리 프로그램에서
  - 직원 ID를 위한 20개의 1
  - 작업 형태를 위한 8개의 1
  - 성별을 위한 1개의 1

- ex)
```c
void print_data(unsigned employee){
  unsigned id_no, job_type;
  char gender;

  id_no = employee & 0xFFFFF;
  job_tyoe = (employee >> 20) & 0xFF;
  gender = (employee >> 28) & 1;

  printf("ID : %u\n", id_no);
  printf("작업 형태 : %u\n", job_type);
  printf("성별 : %s\n", gender ? '여자' : '남자');
}
```


